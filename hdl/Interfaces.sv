interface Simple_Mem_IF ();
    // ------ Write ------
    // wr_addr
    // wr_data
    // wr_ready -- generated by worker as acknowledgement of a write
    // wr_valid -- generated by manager when wr_data and wr_addr are asserted
    // wr_byteEn -- byte enable, LSb <=> LSB, disabled bytes ignored
    // ------ Read ------
    // rd_addr
    // rd_data
    // rd_ready -- generated by worker when rd_data is asserted
    // rd_valid -- generated by manager when rd_addr is asserted
    // rd_byteEn -- byte enable, LSb <=> LSB, disabled bytes zeroed

    //sign extension and shifting for byte or hword accesses should be handled in CPU


    logic           clock;
    logic           reset_n;

    logic [31:0]    wr_addr;
    logic [31:0]    wr_data;
    logic [3:0]     wr_byteEn;
    logic           wr_ready;
    logic           wr_valid;

    logic [31:0]    rd_addr;
    logic [31:0]    rd_data;
    logic [3:0]     rd_byteEn;
    logic           rd_valid;
    logic           rd_ready;

    task CWrite(input logic [31:0] addr, input logic [31:0] data, input int cycleTime);
        wr_addr = addr;
        wr_data = data;
        wr_byteEn = 4'hf;
        wr_valid = '1;
        do #cycleTime;
        while(wr_ready == '0);
        wr_valid = '0;
    endtask

    task CRead(input logic [31:0] addr, output logic [31:0] data, input int cycleTime);
        rd_addr = addr;
        rd_byteEn = 4'hf;
        rd_valid = '1;
        do #cycleTime;
        while(rd_ready == '0);
        data = rd_data;
        rd_valid = '0;
    endtask

    modport COWI (
        input clock, reset_n,

        input wr_addr,
        input wr_data,
        input wr_valid,
        input wr_byteEn,
        output wr_ready,

        input rd_addr,
        input rd_valid,
        input rd_byteEn,
        output rd_data,
        output rd_ready
    );

	modport COMI (
		input clock, reset_n,

        output wr_addr,
        output wr_data,
        output wr_valid,
        output wr_byteEn,
        input wr_ready,

        output rd_addr,
        output rd_valid,
        output rd_byteEn,
        input rd_data,
        input rd_ready
	);

    modport CIWO (
        output clock, reset_n,

        output wr_addr,
        output wr_data,
        output wr_valid,
        output wr_byteEn,
        input wr_ready,

        output rd_addr,
        output rd_valid,
        output rd_byteEn,
        input rd_data,
        input rd_ready
	);

    modport CIMO (
        output clock, reset_n,

        input wr_addr,
        input wr_data,
        input wr_valid,
        input wr_byteEn,
        output wr_ready,

        input rd_addr,
        input rd_valid,
        input rd_byteEn,
        output rd_data,
        output rd_ready
	);

endinterface


interface AXI5_Lite_IF ();
    // TODO: it would be nice if this were parameterized

    // General signals
    logic [ 0:0]    ACLK;
    logic [ 0:0]    ARESETn;
    // TODO: add AWAKEUP for full compliance with the AXI spec

    // Write address channel
    logic [31:0]    AWADDR;
    logic [ 2:0]    AWPROT;
    logic [ 0:0]    AWVALID;
    logic [ 0:0]    AWREADY;
    logic [ 2:0]    AWSIZE;
    // pg144 of spec: AWID and ARID can be 1bit wide and tied off to 1'b0
    //     if master and slave use strictly inorder transactions.
    logic [ 0:0]    AWID;
    // TODO: add AWIDUNQ and AWTRACE for full compliance with the AXI spec

    // Write data channel
    logic [31:0]    WDATA;
    logic [ 3:0]    WSTRB;
    logic [ 0:0]    WVALID;
    logic [ 0:0]    WREADY;
    // TODO: add WTRACE and WPOISON for full compliance with the AXI spec

    // Write response channel
    logic [ 1:0]    BRESP;
    logic [ 0:0]    BVALID;
    logic [ 0:0]    BREADY;
    // BID and RID should be same size as AWID and ARID, respectively
    // Responses include the ID of the transaction
    logic [ 0:0]    BID;
    // TODO: add BIDUNQ and BTRACE for full compliance with the AXI spec

    // Read address channel
    logic [31:0]    ARADDR;
    logic [ 2:0]    ARPROT;
    logic [ 0:0]    ARVALID;
    logic [ 0:0]    ARREADY;
    logic [ 2:0]    ARSIZE;
    // pg144 of spec: AWID and ARID can be 1bit wide and tied off to 1'b0
    //     if master and slave use strictly inorder transactions.
    logic [ 0:0]    ARID;
    // TODO: add ARIDUNQ and ARTRACE for full compliance with the AXI spec

    // Read data + response channel
    logic [31:0]    RDATA;
    logic [ 1:0]    RRESP;
    logic [ 0:0]    RVALID;
    logic [ 0:0]    RREADY;
    // BID and RID should be same size as AWID and ARID, respectively
    // Responses include the ID of the transaction
    logic [ 0:0]    RID;
    // TODO: add RIDUNQ, RTRACE, and RPOISON for full compliance with the AXI spec
    
    modport WORKER (
        // General signals
        input ACLK,
        input ARESETn,
        
        // Write address channel
        input AWADDR,
        input AWPROT,
        input AWVALID,
        output AWREADY,
        input AWSIZE,
        input AWID,

        // Write data channel
        input WDATA,
        input WSTRB,
        input WVALID,
        output WREADY,

        // Write response channel
        output BRESP,
        output BVALID,
        input BREADY,
        output BID,

        // Read address channel
        input ARADDR,
        input ARPROT,
        input ARVALID,
        output ARREADY,
        input ARSIZE,
        input ARID,

        // Read data + response channel
        output RDATA,
        output RRESP,
        output RVALID,
        input RREADY,
        output RID 
    );



    modport MANAGER (
        // General signals
        input ACLK,
        input ARESETn,
        
        // Write address channel
        output AWADDR,
        output AWPROT,
        output AWVALID,
        input AWREADY,
        output AWSIZE,
        output AWID,

        // Write data channel
        output WDATA,
        output WSTRB,
        output WVALID,
        input WREADY,

        // Write response channel
        input BRESP,
        input BVALID,
        output BREADY,
        input BID,

        // Read address channel
        output ARADDR,
        output ARPROT,
        output ARVALID,
        input ARREADY,
        output ARSIZE,
        output ARID,

        // Read data + response channel
        input RDATA,
        input RRESP,
        input RVALID,
        output RREADY,
        input RID 
    );

    // TODO: define modports for clock/reset controller

endinterface
